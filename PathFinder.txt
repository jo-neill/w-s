package joe;import java.util.List;import java.util.ArrayList;import was.GameBoard;import was.GameLocation;public class PathFinder {    GameBoard board;    //Holds nodes that haven't been checked    private final List<Node> open = new ArrayList<Node>();    //Holds already evaluated nodes    private final List<Node> closed = new ArrayList<Node>();    //Used to compare nodes in findPath()    private final List<GameLocation> closedLocs = new ArrayList<GameLocation>();    //Used to compare nodes in findPath()    private final List<GameLocation> openLocs = new ArrayList<GameLocation>();    public List<Node> neighbors = new ArrayList<Node>();    GameLocation start, end;    public ArrayList<GameLocation> sheepFlock;    public PathFinder(GameBoard board, GameLocation start, GameLocation end) {        this.start = start;        this.end = end;        this.board = board;        sheepFlock = board.getSheepPositions();    }    //Checks if a node is empty or contains a sheep    public boolean isValidNode(int x, int y) {        return board.isEmptyCell(x, y) || sheepFlock.contains(new GameLocation(x, y));    }    //Calculates and returns the path of nodes to the target    public List<Node> findPath() {        open.add(new Node(start, end, start));        openLocs.add(start);        while (!open.isEmpty()) {            Node current = getCurrentNode();            openLocs.remove(current.getNodeLocation());            closedLocs.add(current.getNodeLocation());            open.remove(current);            closed.add(current);            if (current.getNodeLocation().equals(end)) {                return pathMaker(current);            }            neighbors = getNeighbors(current);            for (Node neighbor : neighbors) {                int x = neighbor.getNodeLocation().x;                int y = neighbor.getNodeLocation().y;                if (closedLocs.contains(neighbor.getNodeLocation()) || (!isValidNode(x, y))) {                    continue;                }                int gCostOption = current.gValue + current.getValue(neighbor.getNodeLocation(), current.getNodeLocation());                if ((!open.contains(neighbor)) || gCostOption <= neighbor.gValue) {                    neighbor.updateParent(current);                    neighbor.gValue = gCostOption;                    neighbor.fValue = neighbor.gValue + neighbor.hValue;                    if (!openLocs.contains(neighbor.getNodeLocation())) {                        open.add(neighbor);                        openLocs.add(neighbor.getNodeLocation());                    }                }            }        }        return null;    }    //Creates an ArrayList of all the neighbors of the argument node    //Gets all neighbors in a horizontal line, vertical line, and the diagonal neighbors    public List<Node> getNeighbors(Node node) {        List<Node> neighborSet = new ArrayList<Node>();        int xValue = node.getNodeLocation().x;        int yValue = node.getNodeLocation().y;        int leftBoundary, rightBoundary, upBoundary, downBoundary;        leftBoundary = xValue - 2;        rightBoundary = xValue + 2;        upBoundary = yValue - 2;        downBoundary = yValue + 2;        for (int i = 0; i < 2; i++) {            if (leftBoundary < 0) {                leftBoundary++;            }            if (rightBoundary > board.getCols() - 1) {                rightBoundary--;            }            if (upBoundary < 0) {                upBoundary++;            }            if (downBoundary > board.getRows() - 1) {                downBoundary--;            }        }        for (int i = upBoundary; i <= downBoundary; i++) {            Node nodeVert = new Node(start, end, new GameLocation(xValue, i));            int dist = i - yValue;            if (dist >= 2) {                if (!board.isEmptyCell(xValue, i - 1)) {                    continue;                }            } else if (dist <= -2) {                if (!board.isEmptyCell(xValue, i + 1)) {                    continue;                }            }            if (i != yValue) {                neighborSet.add(nodeVert);            }        }        for (int i = leftBoundary; i <= rightBoundary; i++) {            Node nodeHor = new Node(start, end, new GameLocation(i, yValue));            int dist = i - xValue;            if (dist >= 2) {                if (!board.isEmptyCell(i - 1, yValue)) {                    continue;                }            } else if (dist <= -2) {                if (!board.isEmptyCell(i + 1, yValue)) {                    continue;                }            }            if (i != xValue) {                neighborSet.add(nodeHor);            }        }        //Gets all diagonal neighbors        if (xValue - 1 > 0 && yValue - 1 > 0) {            neighborSet.add(new Node(start, end, new GameLocation(xValue - 1, yValue - 1)));        }        if (xValue - 1 > 0 && yValue + 1 < board.getRows() - 1) {            neighborSet.add(new Node(start, end, new GameLocation(xValue - 1, yValue + 1)));        }        if (xValue + 1 < board.getCols() - 1 && yValue + 1 < board.getRows() - 1) {            neighborSet.add(new Node(start, end, new GameLocation(xValue + 1, yValue + 1)));        }        if (xValue + 1 < board.getCols() - 1 && yValue - 1 > 0) {            neighborSet.add(new Node(start, end, new GameLocation(xValue + 1, yValue - 1)));        }        return neighborSet;    }    //Returns a path of nodes to the destination    public List<Node> pathMaker(Node node) {        List<Node> path = new ArrayList<Node>();        List<Node> flippedPath = new ArrayList<Node>();        path.add(node);        while (node.hasParent()) {            node = node.parent;            path.add(node);        }        for (int i = path.size() - 1; i >= 0; i--) {            flippedPath.add(path.get(i));        }        //flippedPath.add(node);        return flippedPath;    }    //Used to get locations from a path of nodes    public List<GameLocation> getPathLocations(List<Node> path) {        List<GameLocation> locations = new ArrayList<GameLocation>();        for (Node node : path) {            locations.add(node.getNodeLocation());        }        return locations;    }    //Returns the node with the lowest f value AKA the current node    private Node getCurrentNode() {        Node lowest = open.get(0);        for (Node node : open) {            if (node.fValue <= lowest.fValue) {                lowest = node;            }        }        return lowest;    }}